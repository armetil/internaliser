from functools import total_ordering
""" TODO:
    consider spreads
    Arithmetics between instruments
    Not allowing arithmetic between instruments of different instruments!
    TickPrice and DeltaTickPric
    SpreadTickPrice and Spread
"""


class TickMeta(type):
    registry = {}

    def __new__(mcs, name, bases, dct):
        is_abstract = dct.get('abstract', False)

        if not is_abstract:
            market_instrument = dct.get('market_instrument')
            if market_instrument is None:
                raise ValueError("Non-abstract Tick must include 'market_instrument'")

            key = id(market_instrument)
            if key in mcs.registry:
                return mcs.registry[key].__class__

        new_cls = super().__new__(mcs, name, bases, dct)

        if not is_abstract:
            instance = new_cls.__new__(new_cls)
            instance.__init__()
            mcs.registry[key] = instance

        return new_cls

    @classmethod
    def get_tick_for_market_instrument(mcs, market_instrument):
        return mcs.registry.get(id(market_instrument))


# Base tick class
class TickBase(metaclass=TickMeta):
    abstract = True

    def __init__(self):
        self.name = self.__class__.__name__

    def round(self, price):
        return round(price / self.tick_size) * self.tick_size

    def convert_from_price(self, price):
        return int(round(price / self.tick_size))

    def convert_to_price(self, ticks):
        return ticks * self.tick_size

    def __repr__(self):
        return f"<Tick tick_size={self.tick_size:.5f}>"


# TickPrice metaclass: injects singleton tick instance into class
class TickPriceFactory(type):
    def __new__(mcs, name, bases, namespace, **kwargs):
        tick_cls = kwargs.get('tick')
        if not tick_cls:
            raise TypeError(f"{name} must be constructed with tick=TickClass")
        market_instrument = kwargs.get('market_instrument')
        # Unique instance of TickBase: Tick by tick_size
        tick_instance = TickMeta.get_tick_for_market_instrument(market_instrument)
        namespace['_tick'] = tick_instance
        namespace['_market_instrument'] = market_instrument

        return super().__new__(mcs, name, bases, namespace)


@total_ordering
class TickPrice:
    """
        Base price class has NO metaclass
        total_ordering: decorator whihc supplies the rest of ordering defintions
    """

    @classmethod
    def from_price(cls, price):
        # Need cls to use the TickPrice class generated by the metaclass
        return cls(cls._tick.convert_from_price(price))

    @staticmethod
    def mid(p1, p2):
        """
        mid only for prices from same TickPrice sibclass
        """
        if type(p1) is not type(p2):
            raise TypeError("Operands must be of the same TickPrice type")
        avg_ticks = (p1.get_ticks() + p2.get_ticks()) / 2
        return FloatPrice(avg_ticks, p1._tick)

    @classmethod
    def get_instrument(cls):
        return cls._market_instrument._instrument

    def __init__(self, ticks):
        self.ticks = ticks

    def get_ticks(self):
        return self.ticks

    def get_tick_size(self):
        return self._tick.tick_size

    def _is_valid_operand(self, other):
        if not hasattr(other, '_tick'):
            raise TypeError("Other object has no associated tick")
        if self._tick is not other._tick:
            # Comparison works because TickPrice derived objects have a _tick and use singleton by tick_size
            raise TypeError("Incompatible tick_size")
        return True

    # Arithmetics
    def __add__(self, other):
        # TickPrice + TickPrice -> DeltaTickPrice [Not financial sound to add two prices and be a tickPrice]
        # TickPrice + DeltaTickPrice -> TickPrice [implies rounding]
        if isinstance(other, DeltaTickPrice) and self._tick is other._tick:
            return self.__class__(self.ticks + other.ticks)
        return NotImplemented

    def __sub__(self, other):
        if isinstance(other, TickPrice) and self._tick is other._tick:
            return DeltaTickPrice(
                self.ticks - other.ticks,
                self._tick,
                self._market_instrument
            )
        if isinstance(other, DeltaTickPrice) and self._tick is other._tick:
            return self.__class__(self.ticks - other.ticks)
        return NotImplemented

    # TickPrice + DeltaTickPrice -> TickPrice
    # TickPrice - DeltaTickPrice -> TickPrice
    # TickPrice - TickPrice -> DeltaTickPrice
    # DeltaTickPrice + DeltaTickPrice -> DeltaTickPrice

    def __repr__(self):
        return f"{self._tick.convert_to_price(self.ticks):.4f} ({self.ticks} ticks)"

    # Comparisons
    def __eq__(self, other):
        if self._is_valid_operand(other):
            return self.ticks == other.ticks
        return NotImplemented

    def __lt__(self, other):
        if self._is_valid_operand(other):
            return self.ticks < other.ticks
        return NotImplemented

    # Convertion to TickPrice sharing the same Instrument
    def convert_to(self, target_tick_price_cls):
        if self.get_instrument() != target_tick_price_cls.get_instrument():
            raise TypeError("Conversion allowed only between TickPrice types of the same instrument")
        float_price = self._tick.convert_to_price(self.ticks)
        return target_tick_price_cls.from_price(float_price)


class DeltaTickPrice:
    def __init__(self, ticks: float, tick, market_instrument):
        self.ticks = float(ticks)
        self._tick = tick
        self._market_instrument = market_instrument

    def _validate_same_instrument(self, other):
        if not isinstance(other, DeltaTickPrice):
            raise TypeError("Operation only allowed with another DeltaTickPrice")
        if self._market_instrument._instrument != other._market_instrument._instrument:
            raise TypeError("DeltaTickPrices must belong to the same instrument")

    def __add__(self, other):
        self._validate_same_instrument(other)
        return DeltaTickPrice(self.ticks + other.ticks, self._tick, self._market_instrument)

    def __sub__(self, other):
        self._validate_same_instrument(other)
        return DeltaTickPrice(self.ticks - other.ticks, self._tick, self._market_instrument)

    def __eq__(self, other):
        self._validate_same_instrument(other)
        return self.ticks == other.ticks

    def to_tick_price(self, tick_price_cls):
        if tick_price_cls.get_instrument() != self._market_instrument._instrument:
            raise TypeError("Tick class must belong to the same instrument")
        return tick_price_cls(self.ticks)



class FloatPrice:
    # FLoatPrice is for Quantitative purpose: VWAP, mid-price
    def __init__(self, ticks, tick):
        self.ticks = float(ticks)
        self._tick = tick

    def to_price(self):
        return self._tick.convert_to_price(self.ticks)

    def __repr__(self):
        return f"{self.to_price():.4f} ({self.ticks:.2f} ticks)"


class Instrument:
    def __init__(self, sym, contract_size):
        self.sym = sym
        self.contract_size = contract_size


class MarketInstrument:
    def __init__(self, instrument: Instrument, market, tick_size):
        self._instrument = instrument
        self.market = market
        self.tick_size = tick_size
        self.tick_value = float(0.01 * instrument.contract_size * tick_size)

        self.Tick = type(
            f"Tick_{tick_size:.5f}",
            (TickBase,),
            {"tick_size": tick_size, "market_instrument": self})
        self.TickPriceFactory = TickPriceFactory(
            f"TickPrice{self}",
            (TickPrice,), {},
            tick=self.Tick,
            market_instrument=self)

    def __eq__(self, other):
        return isinstance(other, MarketInstrument) and (
            self._instrument == other._instrument and
            self.market == other.market and
            self.tick_size == other.tick_size
        )

    def __hash__(self):
        return hash((self._instrument, self.market, self.tick_size))

    def get_tick(self):
        return self.Tick

    def get_tick_price_factory(self):
        return self.TickPriceFactory

    def __repr__(self):
        return f"{self._instrument.sym.capitalize()}{self.market.capitalize()}"


if __name__ == '__main__':
    fgbs = Instrument(sym="FGBS", contract_size=100000)
    fgbm = Instrument(sym="FGBM", contract_size=100000)
    fgbl = Instrument(sym="FGBL", contract_size=100000)
    fgbx = Instrument(sym="FGBX", contract_size=100000)
    oat = Instrument(sym="OAT", contract_size=100000)

    fgbs_eurex = MarketInstrument(fgbs, market="Eurex", tick_size=0.02)
    fgbm_eurex = MarketInstrument(fgbm, market="Eurex", tick_size=0.01)
    fgbl_eurex = MarketInstrument(fgbl, market="Eurex", tick_size=0.01)
    fgbx_eurex = MarketInstrument(fgbx, market="Eurex", tick_size=0.02)
    oat_eurex = MarketInstrument(oat, market="Eurex", tick_size=0.01)

    fgbs_internal = MarketInstrument(fgbs, market="Eurex", tick_size=0.01)
    fgbm_internal = MarketInstrument(fgbm, market="Eurex", tick_size=0.005)
    fgbl_internal = MarketInstrument(fgbl, market="Eurex", tick_size=0.005)
    fgbx_internal = MarketInstrument(fgbx, market="Eurex", tick_size=0.01)
    oat_internal = MarketInstrument(oat, market="Eurex", tick_size=0.005)

    fgbl_eurex_price_factory = fgbl_eurex.get_tick_price_factory()

    tp1 = fgbl_eurex_price_factory.from_price(100.0056)
    # tp1 is a TickPriceFGBL!!!
    print(f"{type(tp1)=}")
    print(f"{tp1.__class__.__class__=}")
    print(f"{tp1=}")  # 100.01
    print(f"{tp1.get_ticks()=}")
    print(f"{tp1.get_tick_size()=}")

    tp1 = fgbl_eurex_price_factory.from_price(100.0045)
    # tp1 is a TickPriceFGBL!!!
    print(f"{type(tp1)=}")
    print(f"{tp1.__class__.__class__=}")
    print(f"{tp1=}")  # 100.01

    oat_eurex_price_meta = oat_eurex.get_tick_price_factory()
    oat1 = oat_eurex_price_meta.from_price(100.0056)
    print(f"{type(oat1)=}")
    print(f"{oat1.__class__.__class__=}")
    print(f"{oat1=}")  # 100.01

    assert fgbl_eurex.get_tick() is not oat_eurex.get_tick()
    assert fgbl_eurex.get_tick() is not fgbs_eurex.get_tick()

    tp1 = fgbl_eurex_price_factory.from_price(100.01)
    tp2 = fgbl_eurex_price_factory.from_price(100.02)
    dtpsum = tp1 - tp2
    print(f"{dtpsum=}")
    print(f"{dtpsum.__class__=}")

    print(f"{tp1 < tp2=}")

    midtp = TickPrice.mid(tp1, tp2)
    print(f"{midtp=}")
    print(f"{midtp.__class__=}")

    # Not authorised
    # TickPrice.mid(tp1, oat1)

    tpi1 = tp1.convert_to(fgbl_internal.get_tick_price_factory())
    print(f"{tpi1=}")
    print(f"{tpi1.__class__=}")
